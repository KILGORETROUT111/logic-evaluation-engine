# core/evaluation.py

from core.expressions import Functor, Var, Value
from enum import Enum


class State(Enum):
    JAM = "JAM"
    MEM = "MEM"
    ALIVE = "ALIVE"
    VAC = "VAC"


def evaluate(expr, context, trace):
    def go(node):
        if isinstance(node, Functor):
            name = node.name.upper()
            args = node.args
            trace.setdefault(name, []).append(node)

            # SUB logic (substitution into context)
            if name == "SUB" and len(args) == 2:
                varname = args[0]
                value = args[1]
                if isinstance(varname, Var) and isinstance(value, Value):
                    context[varname.name] = value.val
                    return State.ALIVE
                elif isinstance(varname, Var) and isinstance(value, Functor):
                    context[varname.name] = value
                    return State.ALIVE
                else:
                    return State.VAC

            # EEX: Counterfactual Entailment
            elif name == "EEX":
                if len(args) == 2:
                    return State.VAC if args[1].name == "JAM" else State.ALIVE
                return State.VAC

            # MEM: Memory recall
            elif name == "MEM":
                return State.MEM

            # JAM phase: interruption
            elif name == "JAM":
                return State.JAM

            # VAC: Void
            elif name == "VAC":
                return State.VAC

            # EX or ROOT: Recursive check
            elif name in {"EX", "ROOT", "NODE"}:
                for child in args:
                    go(child)
                return State.ALIVE

            # Unknown functor
            else:
                return State.VAC

        elif isinstance(node, Var):
            trace.setdefault("ALIVE", []).append(node)
            return State.ALIVE

        elif isinstance(node, Value):
            trace.setdefault("ALIVE", []).append(node)
            return State.ALIVE

        else:
            return State.VAC

    final_state = go(expr)
    return final_state, trace


def evaluate_full(expr, context=None):
    if context is None:
        context = {}
    trace = {}
    state, trace = evaluate(expr, context, trace)
    return state, trace
